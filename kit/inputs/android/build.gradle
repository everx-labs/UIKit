import groovy.json.JsonSlurper

def findNodeModulesWithRN(path = '..', level = 0) {
    def rnPackageJsonFile = new File(rootProject.projectDir, path + "/node_modules/react-native/package.json")
    if (file(rnPackageJsonFile).exists()) {
        return new File(rootProject.projectDir, path + "/node_modules").absolutePath
    }
    // If it more that 10 than we assume that it's not an RN project
    if (level == 10) {
        throw "You can't use uikit.inputs in not RN project"
    }
    return findNodeModulesWithRN("${path}/..", level + 1)
}
def NODE_MODULES_DIR = findNodeModulesWithRN();

def reactProperties = new Properties()
file("$NODE_MODULES_DIR/react-native/ReactAndroid/gradle.properties").withInputStream { reactProperties.load(it) }
def REACT_NATIVE_VERSION = reactProperties.getProperty("VERSION_NAME").split("\\.")[1].toInteger()

def FOR_HERMES = System.getenv("FOR_HERMES") == "True"
rootProject.getSubprojects().forEach({project ->
    if (project.plugins.hasPlugin("com.android.application")) {
        FOR_HERMES = project.ext.react.enableHermes
    }
})

buildscript {
    repositories {
        google()
        mavenCentral()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:4.2.2'
    }
}

apply plugin: 'com.android.library'

project.ext {
    buildToolsVersion = rootProject.ext.has("buildToolsVersion") ? rootProject.ext.buildToolsVersion : '30.0.2'
    minSdkVersion = rootProject.ext.has("minSdkVersion") ? rootProject.ext.minSdkVersion : 24
    compileSdkVersion = rootProject.ext.has("compileSdkVersion") ? rootProject.ext.compileSdkVersion : 30
    targetSdkVersion = rootProject.ext.has("targetSdkVersion") ? rootProject.ext.targetSdkVersion : 30
    supportLibVersion = rootProject.ext.has("supportLibVersion") ? rootProject.ext.supportLibVersion : '30.0.2'
}

android {
    compileSdkVersion project.ext.compileSdkVersion
    buildToolsVersion project.ext.buildToolsVersion

    defaultConfig {
        minSdkVersion project.ext.minSdkVersion
        targetSdkVersion project.ext.targetSdkVersion
        versionCode 1
        versionName "3.0.0"

        externalNativeBuild {
            cmake {
                cppFlags "-O2 -frtti -fexceptions -std=c++1y -Wall -Wno-unused-variable -fstack-protector-all"
                abiFilters 'x86', 'x86_64', 'armeabi-v7a', 'arm64-v8a'
                arguments "-DANDROID_STL=c++_shared",
                        "-DANDROID_TOOLCHAIN=clang",
                        "-DREACT_NATIVE_VERSION=${REACT_NATIVE_VERSION}",
                        "-DNODE_MODULES_DIR=${NODE_MODULES_DIR}",
                        "-DFOR_HERMES=${FOR_HERMES}"
            }
        }
    }

    externalNativeBuild {
        cmake {
            path "CMakeLists.txt"
        }
    }

    packagingOptions {
        excludes = ["**/libc++_shared.so", "**/libfbjni.so", "**/libjsi.so", "**/libreactnativejni.so", "**/libfolly_json.so", "**/libreanimated.so", "**/libjscexecutor.so"]
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    lintOptions {
        disable 'GradleCompatible'
    }

    configurations {
        extractHeaders
        extractJNI
    }
}

repositories {
    mavenCentral()
    google()

    def found = false
    def defaultDir = null
    def androidSourcesName = 'React Native sources'

    if (rootProject.ext.has('reactNativeAndroidRoot')) {
        defaultDir = rootProject.ext.get('reactNativeAndroidRoot')
    } else {
        defaultDir = new File(
                projectDir,
                '/../../../node_modules/react-native/android'
        )
    }

    if (defaultDir.exists()) {
        maven {
            url defaultDir.toString()
            name androidSourcesName
        }

        logger.info(":${project.name}:reactNativeAndroidRoot ${defaultDir.canonicalPath}")
        found = true
    } else {
        def parentDir = rootProject.projectDir

        1.upto(5, {
            if (found) return true
            parentDir = parentDir.parentFile

            def androidSourcesDir = new File(
                    parentDir,
                    'node_modules/react-native'
            )

            def androidPrebuiltBinaryDir = new File(
                    parentDir,
                    'node_modules/react-native/android'
            )

            if (androidPrebuiltBinaryDir.exists()) {
                maven {
                    url androidPrebuiltBinaryDir.toString()
                    name androidSourcesName
                }

                logger.info(":${project.name}:reactNativeAndroidRoot ${androidPrebuiltBinaryDir.canonicalPath}")
                found = true
            } else if (androidSourcesDir.exists()) {
                maven {
                    url androidSourcesDir.toString()
                    name androidSourcesName
                }

                logger.info(":${project.name}:reactNativeAndroidRoot ${androidSourcesDir.canonicalPath}")
                found = true
            }
        })
    }

    if (!found) {
        throw new GradleException(
                "${project.name}: unable to locate React Native android sources. " +
                        "Ensure you have you installed React Native as a dependency in your project and try again."
        )
    }
}

dependencies {
    // noinspection GradleDynamicVersion
    implementation 'com.facebook.react:react-native:+'
    implementation 'androidx.core:core:1.6.0'
    implementation project(':react-native-reanimated')


    //noinspection GradleDynamicVersion
    extractHeaders "com.facebook.fbjni:fbjni:+:headers"
    //noinspection GradleDynamicVersion
    extractJNI "com.facebook.fbjni:fbjni:+"

    // def rnAAR = fileTree("${NODE_MODULES_DIR}/react-native/android").matching({ it.include "**/**/*.aar" }).singleFile

    def buildType = "debug"
    tasks.all({ task ->
      if (task.name == "buildCMakeRelease") {
        buildType = "release"
      }
    })
    def rnAarMatcher = "**/react-native/**/*${buildType}.aar"
    if (REACT_NATIVE_VERSION < 69) {
      rnAarMatcher = "**/**/*.aar"
    }

    def rnAAR = fileTree("${NODE_MODULES_DIR}/react-native/android/").matching({ it.include rnAarMatcher }).singleFile

    def jsEngine = FOR_HERMES ? "hermes" : "jsc"
    def reaAAR = "${NODE_MODULES_DIR}/react-native-reanimated/android/react-native-reanimated-${REACT_NATIVE_VERSION}-${jsEngine}.aar"

    extractJNI(files(rnAAR, reaAAR))
}

task extractAARHeaders {
    doLast {
        configurations.extractHeaders.files.each {
            def file = it.absoluteFile
            copy {
                from zipTree(file)
                into "$buildDir/$file.name"
                include "**/*.h"
            }
        }
    }
}

task extractJNIFiles {
    doLast {
        configurations.extractJNI.files.each {
            def file = it.absoluteFile

            copy {
                from zipTree(file)
                into "$buildDir/$file.name"
                include "jni/**/*"
            }
        }
    }
}

extractJNIFiles.mustRunAfter extractAARHeaders

// pre-native build pipeline

tasks.whenTaskAdded { task ->
    if (!task.name.contains('Clean') && (task.name.contains('externalNative') || task.name.contains('CMake'))) {
        task.dependsOn(extractAARHeaders)
        task.dependsOn(extractJNIFiles)
    }
}